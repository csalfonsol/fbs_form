{"ast":null,"code":"function getTotalFrozenColumnWidth(columns, lastFrozenColumnIndex) {\n  if (lastFrozenColumnIndex === -1) {\n    return 0;\n  }\n\n  var lastFrozenColumn = columns[lastFrozenColumnIndex];\n  return lastFrozenColumn.left + lastFrozenColumn.width;\n}\n\nexport function getVerticalRangeToRender(height, rowHeight, scrollTop, rowsCount, renderBatchSize) {\n  var overscanThreshold = 4;\n  var rowVisibleStartIdx = Math.floor(scrollTop / rowHeight);\n  var rowVisibleEndIdx = Math.min(rowsCount - 1, Math.floor((scrollTop + height) / rowHeight));\n  var rowOverscanStartIdx = Math.max(0, Math.floor((rowVisibleStartIdx - overscanThreshold) / renderBatchSize) * renderBatchSize);\n  var rowOverscanEndIdx = Math.min(rowsCount - 1, Math.ceil((rowVisibleEndIdx + overscanThreshold) / renderBatchSize) * renderBatchSize);\n  return [rowOverscanStartIdx, rowOverscanEndIdx];\n}\nexport function getHorizontalRangeToRender(_a) {\n  var columnMetrics = _a.columnMetrics,\n      scrollLeft = _a.scrollLeft;\n  var columns = columnMetrics.columns,\n      lastFrozenColumnIndex = columnMetrics.lastFrozenColumnIndex,\n      viewportWidth = columnMetrics.viewportWidth; // get the viewport's left side and right side positions for non-frozen columns\n\n  var totalFrozenColumnWidth = getTotalFrozenColumnWidth(columns, lastFrozenColumnIndex);\n  var viewportLeft = scrollLeft + totalFrozenColumnWidth;\n  var viewportRight = scrollLeft + viewportWidth; // get first and last non-frozen column indexes\n\n  var lastColIdx = columns.length - 1;\n  var firstUnfrozenColumnIdx = Math.min(lastFrozenColumnIndex + 1, lastColIdx); // skip rendering non-frozen columns if the frozen columns cover the entire viewport\n\n  if (viewportLeft >= viewportRight) {\n    return {\n      colVisibleStartIdx: firstUnfrozenColumnIdx,\n      colVisibleEndIdx: firstUnfrozenColumnIdx,\n      colOverscanStartIdx: firstUnfrozenColumnIdx,\n      colOverscanEndIdx: firstUnfrozenColumnIdx\n    };\n  } // get the first visible non-frozen column index\n\n\n  var colVisibleStartIdx = firstUnfrozenColumnIdx;\n\n  while (colVisibleStartIdx < lastColIdx) {\n    var _b = columns[colVisibleStartIdx],\n        left = _b.left,\n        width = _b.width; // if the right side of the columnn is beyond the left side of the available viewport,\n    // then it is the first column that's at least partially visible\n\n    if (left + width > viewportLeft) {\n      break;\n    }\n\n    colVisibleStartIdx++;\n  } // get the last visible non-frozen column index\n\n\n  var colVisibleEndIdx = colVisibleStartIdx;\n\n  while (colVisibleEndIdx < lastColIdx) {\n    var _c = columns[colVisibleEndIdx],\n        left = _c.left,\n        width = _c.width; // if the right side of the column is beyond or equal to the right side of the available viewport,\n    // then it the last column that's at least partially visible, as the previous column's right side is not beyond the viewport.\n\n    if (left + width >= viewportRight) {\n      break;\n    }\n\n    colVisibleEndIdx++;\n  }\n\n  var colOverscanStartIdx = Math.max(firstUnfrozenColumnIdx, colVisibleStartIdx - 1);\n  var colOverscanEndIdx = Math.min(lastColIdx, colVisibleEndIdx + 1);\n  return {\n    colVisibleStartIdx: colVisibleStartIdx,\n    colVisibleEndIdx: colVisibleEndIdx,\n    colOverscanStartIdx: colOverscanStartIdx,\n    colOverscanEndIdx: colOverscanEndIdx\n  };\n}","map":{"version":3,"sources":["../../src/utils/viewportUtils.ts"],"names":[],"mappings":"AAEA,SAAS,yBAAT,CAAsC,OAAtC,EAAsE,qBAAtE,EAAmG;AACjG,MAAI,qBAAqB,KAAK,CAAC,CAA/B,EAAkC;AAChC,WAAO,CAAP;AACD;;AACD,MAAM,gBAAgB,GAAG,OAAO,CAAC,qBAAD,CAAhC;AACA,SAAO,gBAAgB,CAAC,IAAjB,GAAwB,gBAAgB,CAAC,KAAhD;AACD;;AAED,OAAM,SAAU,wBAAV,CACJ,MADI,EAEJ,SAFI,EAGJ,SAHI,EAIJ,SAJI,EAKJ,eALI,EAKmB;AAEvB,MAAM,iBAAiB,GAAG,CAA1B;AACA,MAAM,kBAAkB,GAAG,IAAI,CAAC,KAAL,CAAW,SAAS,GAAG,SAAvB,CAA3B;AACA,MAAM,gBAAgB,GAAG,IAAI,CAAC,GAAL,CAAS,SAAS,GAAG,CAArB,EAAwB,IAAI,CAAC,KAAL,CAAW,CAAC,SAAS,GAAG,MAAb,IAAuB,SAAlC,CAAxB,CAAzB;AACA,MAAM,mBAAmB,GAAG,IAAI,CAAC,GAAL,CAAS,CAAT,EAAY,IAAI,CAAC,KAAL,CAAW,CAAC,kBAAkB,GAAG,iBAAtB,IAA2C,eAAtD,IAAyE,eAArF,CAA5B;AACA,MAAM,iBAAiB,GAAG,IAAI,CAAC,GAAL,CAAS,SAAS,GAAG,CAArB,EAAwB,IAAI,CAAC,IAAL,CAAU,CAAC,gBAAgB,GAAG,iBAApB,IAAyC,eAAnD,IAAsE,eAA9F,CAA1B;AAEA,SAAO,CAAC,mBAAD,EAAsB,iBAAtB,CAAP;AACD;AAcD,OAAM,SAAU,0BAAV,CAAwC,EAAxC,EAG6B;MAFjC,aAAA,GAAA,EAAA,CAAA,a;MACA,UAAA,GAAA,EAAA,CAAA,U;AAEQ,MAAA,OAAA,GAAA,aAAA,CAAA,OAAA;AAAA,MAAS,qBAAA,GAAA,aAAA,CAAA,qBAAT;AAAA,MAAgC,aAAA,GAAA,aAAA,CAAA,aAAhC,CADyB,CAEjC;;AACA,MAAM,sBAAsB,GAAG,yBAAyB,CAAC,OAAD,EAAU,qBAAV,CAAxD;AACA,MAAM,YAAY,GAAG,UAAU,GAAG,sBAAlC;AACA,MAAM,aAAa,GAAG,UAAU,GAAG,aAAnC,CALiC,CAMjC;;AACA,MAAM,UAAU,GAAG,OAAO,CAAC,MAAR,GAAiB,CAApC;AACA,MAAM,sBAAsB,GAAG,IAAI,CAAC,GAAL,CAAS,qBAAqB,GAAG,CAAjC,EAAoC,UAApC,CAA/B,CARiC,CAUjC;;AACA,MAAI,YAAY,IAAI,aAApB,EAAmC;AACjC,WAAO;AACL,MAAA,kBAAkB,EAAE,sBADf;AAEL,MAAA,gBAAgB,EAAE,sBAFb;AAGL,MAAA,mBAAmB,EAAE,sBAHhB;AAIL,MAAA,iBAAiB,EAAE;AAJd,KAAP;AAMD,GAlBgC,CAoBjC;;;AACA,MAAI,kBAAkB,GAAG,sBAAzB;;AACA,SAAO,kBAAkB,GAAG,UAA5B,EAAwC;AAChC,QAAA,EAAA,GAAA,OAAA,CAAA,kBAAA,CAAA;AAAA,QAAE,IAAA,GAAA,EAAA,CAAA,IAAF;AAAA,QAAQ,KAAA,GAAA,EAAA,CAAA,KAAR,CADgC,CAEtC;AACA;;AACA,QAAI,IAAI,GAAG,KAAP,GAAe,YAAnB,EAAiC;AAC/B;AACD;;AACD,IAAA,kBAAkB;AACnB,GA9BgC,CAgCjC;;;AACA,MAAI,gBAAgB,GAAG,kBAAvB;;AACA,SAAO,gBAAgB,GAAG,UAA1B,EAAsC;AAC9B,QAAA,EAAA,GAAA,OAAA,CAAA,gBAAA,CAAA;AAAA,QAAE,IAAA,GAAA,EAAA,CAAA,IAAF;AAAA,QAAQ,KAAA,GAAA,EAAA,CAAA,KAAR,CAD8B,CAEpC;AACA;;AACA,QAAI,IAAI,GAAG,KAAP,IAAgB,aAApB,EAAmC;AACjC;AACD;;AACD,IAAA,gBAAgB;AACjB;;AAED,MAAM,mBAAmB,GAAG,IAAI,CAAC,GAAL,CAAS,sBAAT,EAAiC,kBAAkB,GAAG,CAAtD,CAA5B;AACA,MAAM,iBAAiB,GAAG,IAAI,CAAC,GAAL,CAAS,UAAT,EAAqB,gBAAgB,GAAG,CAAxC,CAA1B;AAEA,SAAO;AAAE,IAAA,kBAAkB,EAAA,kBAApB;AAAsB,IAAA,gBAAgB,EAAA,gBAAtC;AAAwC,IAAA,mBAAmB,EAAA,mBAA3D;AAA6D,IAAA,iBAAiB,EAAA;AAA9E,GAAP;AACD","sourcesContent":["import { CalculatedColumn, ColumnMetrics } from '../common/types';\n\nfunction getTotalFrozenColumnWidth<R>(columns: CalculatedColumn<R>[], lastFrozenColumnIndex: number): number {\n  if (lastFrozenColumnIndex === -1) {\n    return 0;\n  }\n  const lastFrozenColumn = columns[lastFrozenColumnIndex];\n  return lastFrozenColumn.left + lastFrozenColumn.width;\n}\n\nexport function getVerticalRangeToRender(\n  height: number,\n  rowHeight: number,\n  scrollTop: number,\n  rowsCount: number,\n  renderBatchSize: number\n) {\n  const overscanThreshold = 4;\n  const rowVisibleStartIdx = Math.floor(scrollTop / rowHeight);\n  const rowVisibleEndIdx = Math.min(rowsCount - 1, Math.floor((scrollTop + height) / rowHeight));\n  const rowOverscanStartIdx = Math.max(0, Math.floor((rowVisibleStartIdx - overscanThreshold) / renderBatchSize) * renderBatchSize);\n  const rowOverscanEndIdx = Math.min(rowsCount - 1, Math.ceil((rowVisibleEndIdx + overscanThreshold) / renderBatchSize) * renderBatchSize);\n\n  return [rowOverscanStartIdx, rowOverscanEndIdx] as const;\n}\n\nexport interface HorizontalRangeToRender {\n  colVisibleStartIdx: number;\n  colVisibleEndIdx: number;\n  colOverscanStartIdx: number;\n  colOverscanEndIdx: number;\n}\n\nexport interface HorizontalRangeToRenderParams<R> {\n  columnMetrics: ColumnMetrics<R>;\n  scrollLeft: number;\n}\n\nexport function getHorizontalRangeToRender<R>({\n  columnMetrics,\n  scrollLeft\n}: HorizontalRangeToRenderParams<R>): HorizontalRangeToRender {\n  const { columns, lastFrozenColumnIndex, viewportWidth } = columnMetrics;\n  // get the viewport's left side and right side positions for non-frozen columns\n  const totalFrozenColumnWidth = getTotalFrozenColumnWidth(columns, lastFrozenColumnIndex);\n  const viewportLeft = scrollLeft + totalFrozenColumnWidth;\n  const viewportRight = scrollLeft + viewportWidth;\n  // get first and last non-frozen column indexes\n  const lastColIdx = columns.length - 1;\n  const firstUnfrozenColumnIdx = Math.min(lastFrozenColumnIndex + 1, lastColIdx);\n\n  // skip rendering non-frozen columns if the frozen columns cover the entire viewport\n  if (viewportLeft >= viewportRight) {\n    return {\n      colVisibleStartIdx: firstUnfrozenColumnIdx,\n      colVisibleEndIdx: firstUnfrozenColumnIdx,\n      colOverscanStartIdx: firstUnfrozenColumnIdx,\n      colOverscanEndIdx: firstUnfrozenColumnIdx\n    };\n  }\n\n  // get the first visible non-frozen column index\n  let colVisibleStartIdx = firstUnfrozenColumnIdx;\n  while (colVisibleStartIdx < lastColIdx) {\n    const { left, width } = columns[colVisibleStartIdx];\n    // if the right side of the columnn is beyond the left side of the available viewport,\n    // then it is the first column that's at least partially visible\n    if (left + width > viewportLeft) {\n      break;\n    }\n    colVisibleStartIdx++;\n  }\n\n  // get the last visible non-frozen column index\n  let colVisibleEndIdx = colVisibleStartIdx;\n  while (colVisibleEndIdx < lastColIdx) {\n    const { left, width } = columns[colVisibleEndIdx];\n    // if the right side of the column is beyond or equal to the right side of the available viewport,\n    // then it the last column that's at least partially visible, as the previous column's right side is not beyond the viewport.\n    if (left + width >= viewportRight) {\n      break;\n    }\n    colVisibleEndIdx++;\n  }\n\n  const colOverscanStartIdx = Math.max(firstUnfrozenColumnIdx, colVisibleStartIdx - 1);\n  const colOverscanEndIdx = Math.min(lastColIdx, colVisibleEndIdx + 1);\n\n  return { colVisibleStartIdx, colVisibleEndIdx, colOverscanStartIdx, colOverscanEndIdx };\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}