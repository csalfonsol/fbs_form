{"ast":null,"code":"import { __read, __rest } from \"tslib\";\nimport React, { forwardRef, useState, useRef, useEffect, useLayoutEffect, useMemo, useImperativeHandle, createElement } from 'react';\nimport { isValidElementType } from 'react-is';\nimport Header from './Header';\nimport Canvas from './Canvas';\nimport { legacyCellContentRenderer } from './Cell/cellContentRenderers';\nimport { getColumnMetrics } from './utils/columnUtils';\nimport EventBus from './EventBus';\nimport { CellNavigationMode, EventTypes, UpdateActions, HeaderRowType } from './common/enums';\n/**\r\n * Main API Component to render a data grid of rows and columns\r\n *\r\n * @example\r\n *\r\n * <DataGrid columns={columns} rowGetter={i => rows[i]} rowsCount={3} />\r\n*/\n\nfunction DataGrid(_a, ref) {\n  var _b = _a.rowKey,\n      rowKey = _b === void 0 ? 'id' : _b,\n      _c = _a.rowHeight,\n      rowHeight = _c === void 0 ? 35 : _c,\n      _d = _a.headerFiltersHeight,\n      headerFiltersHeight = _d === void 0 ? 45 : _d,\n      _e = _a.minColumnWidth,\n      minColumnWidth = _e === void 0 ? 80 : _e,\n      _f = _a.minHeight,\n      minHeight = _f === void 0 ? 350 : _f,\n      width = _a.minWidth,\n      _g = _a.enableCellSelect,\n      enableCellSelect = _g === void 0 ? false : _g,\n      _h = _a.enableCellAutoFocus,\n      enableCellAutoFocus = _h === void 0 ? true : _h,\n      _j = _a.cellNavigationMode,\n      cellNavigationMode = _j === void 0 ? CellNavigationMode.NONE : _j,\n      _k = _a.editorPortalTarget,\n      editorPortalTarget = _k === void 0 ? document.body : _k,\n      _l = _a.renderBatchSize,\n      renderBatchSize = _l === void 0 ? 8 : _l,\n      _m = _a.defaultCellContentRenderer,\n      defaultCellContentRenderer = _m === void 0 ? legacyCellContentRenderer : _m,\n      columns = _a.columns,\n      rowsCount = _a.rowsCount,\n      rowGetter = _a.rowGetter,\n      cellRangeSelection = _a.cellRangeSelection,\n      selectedRows = _a.selectedRows,\n      onSelectedRowsChange = _a.onSelectedRowsChange,\n      props = __rest(_a, [\"rowKey\", \"rowHeight\", \"headerFiltersHeight\", \"minColumnWidth\", \"minHeight\", \"minWidth\", \"enableCellSelect\", \"enableCellAutoFocus\", \"cellNavigationMode\", \"editorPortalTarget\", \"renderBatchSize\", \"defaultCellContentRenderer\", \"columns\", \"rowsCount\", \"rowGetter\", \"cellRangeSelection\", \"selectedRows\", \"onSelectedRowsChange\"]);\n\n  var _o = __read(useState(function () {\n    return new Map();\n  }), 2),\n      columnWidths = _o[0],\n      setColumnWidths = _o[1];\n\n  var _p = __read(useState(function () {\n    return new EventBus();\n  }), 1),\n      eventBus = _p[0];\n\n  var _q = __read(useState(0), 2),\n      gridWidth = _q[0],\n      setGridWidth = _q[1];\n\n  var gridRef = useRef(null);\n  var headerRef = useRef(null);\n  var lastSelectedRowIdx = useRef(-1);\n  var viewportWidth = (width || gridWidth) - 2; // 2 for border width;\n\n  var scrollLeft = useRef(0);\n  var columnMetrics = useMemo(function () {\n    if (viewportWidth <= 0) return null;\n    return getColumnMetrics({\n      columns: columns,\n      minColumnWidth: minColumnWidth,\n      viewportWidth: viewportWidth,\n      columnWidths: columnWidths,\n      defaultCellContentRenderer: defaultCellContentRenderer\n    });\n  }, [columnWidths, columns, defaultCellContentRenderer, minColumnWidth, viewportWidth]);\n  useLayoutEffect(function () {\n    // Do not calculate the width if minWidth is provided\n    if (width) return;\n\n    function onResize() {\n      // Immediately re-render when the component is mounted to get valid columnMetrics.\n      setGridWidth(gridRef.current.getBoundingClientRect().width);\n    }\n\n    onResize();\n    window.addEventListener('resize', onResize);\n    return function () {\n      window.removeEventListener('resize', onResize);\n    };\n  }, [width]);\n  useEffect(function () {\n    if (!cellRangeSelection) return;\n\n    function handleWindowMouseUp() {\n      eventBus.dispatch(EventTypes.SELECT_END);\n    }\n\n    window.addEventListener('mouseup', handleWindowMouseUp);\n    return function () {\n      window.removeEventListener('mouseup', handleWindowMouseUp);\n    };\n  }, [eventBus, cellRangeSelection]);\n\n  function selectCell(_a, openEditor) {\n    var idx = _a.idx,\n        rowIdx = _a.rowIdx;\n    eventBus.dispatch(EventTypes.SELECT_CELL, {\n      rowIdx: rowIdx,\n      idx: idx\n    }, openEditor);\n  }\n\n  function getColumn(idx) {\n    return columnMetrics.columns[idx];\n  }\n\n  function handleColumnResize(column, width) {\n    var newColumnWidths = new Map(columnWidths);\n    width = Math.max(width, minColumnWidth);\n    newColumnWidths.set(column.key, width);\n    setColumnWidths(newColumnWidths);\n\n    if (props.onColumnResize) {\n      props.onColumnResize(column.idx, width);\n    }\n  }\n\n  function handleScroll(scrollPosition) {\n    if (headerRef.current && scrollLeft.current !== scrollPosition.scrollLeft) {\n      scrollLeft.current = scrollPosition.scrollLeft;\n      headerRef.current.setScrollLeft(scrollPosition.scrollLeft);\n    }\n\n    if (props.onScroll) {\n      props.onScroll(scrollPosition);\n    }\n  }\n\n  function handleDragEnter(overRowIdx) {\n    eventBus.dispatch(EventTypes.DRAG_ENTER, overRowIdx);\n  }\n\n  function handleCellClick(_a) {\n    var rowIdx = _a.rowIdx,\n        idx = _a.idx;\n    var onRowClick = props.onRowClick;\n    selectCell({\n      rowIdx: rowIdx,\n      idx: idx\n    });\n\n    if (onRowClick) {\n      onRowClick(rowIdx, rowGetter(rowIdx), getColumn(idx));\n    }\n  }\n\n  function handleCellMouseDown(position) {\n    eventBus.dispatch(EventTypes.SELECT_START, position);\n  }\n\n  function handleCellMouseEnter(position) {\n    eventBus.dispatch(EventTypes.SELECT_UPDATE, position);\n  }\n\n  function handleCellContextMenu(position) {\n    selectCell(position);\n  }\n\n  function handleCellDoubleClick(_a) {\n    var rowIdx = _a.rowIdx,\n        idx = _a.idx;\n    var onRowDoubleClick = props.onRowDoubleClick;\n\n    if (onRowDoubleClick) {\n      onRowDoubleClick(rowIdx, rowGetter(rowIdx), getColumn(idx));\n    }\n\n    openCellEditor(rowIdx, idx);\n  }\n\n  var handleDragHandleDoubleClick = function (e) {\n    var _a;\n\n    var cellKey = getColumn(e.idx).key;\n    handleGridRowsUpdated(cellKey, e.rowIdx, rowsCount - 1, (_a = {}, _a[cellKey] = e.rowData[cellKey], _a), UpdateActions.COLUMN_FILL);\n  };\n\n  var handleGridRowsUpdated = function (cellKey, fromRow, toRow, updated, action, originRow) {\n    var onGridRowsUpdated = props.onGridRowsUpdated;\n\n    if (!onGridRowsUpdated) {\n      return;\n    }\n\n    var rowIds = [];\n    var start = Math.min(fromRow, toRow);\n    var end = Math.max(fromRow, toRow);\n\n    for (var i = start; i <= end; i++) {\n      rowIds.push(rowGetter(i)[rowKey]);\n    }\n\n    var fromRowData = rowGetter(action === UpdateActions.COPY_PASTE ? originRow : fromRow);\n    var fromRowId = fromRowData[rowKey];\n    var toRowId = rowGetter(toRow)[rowKey];\n    onGridRowsUpdated({\n      cellKey: cellKey,\n      fromRow: fromRow,\n      toRow: toRow,\n      fromRowId: fromRowId,\n      toRowId: toRowId,\n      rowIds: rowIds,\n      updated: updated,\n      action: action,\n      fromRowData: fromRowData\n    });\n  };\n\n  function handleCommit(commit) {\n    var targetRow = commit.rowIdx;\n    handleGridRowsUpdated(commit.cellKey, targetRow, targetRow, commit.updated, UpdateActions.CELL_UPDATE);\n  }\n\n  function getHeaderRows() {\n    var headerRowHeight = props.headerRowHeight,\n        onAddFilter = props.onAddFilter;\n    return [{\n      height: headerRowHeight || rowHeight,\n      rowType: HeaderRowType.HEADER\n    }, props.enableHeaderFilters ? {\n      rowType: HeaderRowType.FILTER,\n      filterable: true,\n      onFilterChange: onAddFilter,\n      height: headerFiltersHeight || headerRowHeight || rowHeight\n    } : undefined];\n  }\n\n  function openCellEditor(rowIdx, idx) {\n    selectCell({\n      rowIdx: rowIdx,\n      idx: idx\n    }, true);\n  }\n\n  function scrollToColumn(colIdx) {\n    eventBus.dispatch(EventTypes.SCROLL_TO_COLUMN, colIdx);\n  }\n\n  function handleRowSelectionChange(rowIdx, row, checked, isShiftClick) {\n    if (!onSelectedRowsChange) return;\n    var newSelectedRows = new Set(selectedRows);\n\n    if (checked) {\n      newSelectedRows.add(row[rowKey]);\n      var previousRowIdx = lastSelectedRowIdx.current;\n      lastSelectedRowIdx.current = rowIdx;\n\n      if (isShiftClick && previousRowIdx !== -1 && previousRowIdx !== rowIdx) {\n        var step = Math.sign(rowIdx - previousRowIdx);\n\n        for (var i = previousRowIdx + step; i !== rowIdx; i += step) {\n          newSelectedRows.add(rowGetter(i)[rowKey]);\n        }\n      }\n    } else {\n      newSelectedRows.delete(row[rowKey]);\n      lastSelectedRowIdx.current = -1;\n    }\n\n    onSelectedRowsChange(newSelectedRows);\n  }\n\n  useImperativeHandle(ref, function () {\n    return {\n      scrollToColumn: scrollToColumn,\n      selectCell: selectCell,\n      openCellEditor: openCellEditor\n    };\n  });\n  var cellMetaData = {\n    rowKey: rowKey,\n    onCellClick: handleCellClick,\n    onCellContextMenu: handleCellContextMenu,\n    onCellDoubleClick: handleCellDoubleClick,\n    onCellExpand: props.onCellExpand,\n    onRowExpandToggle: props.onRowExpandToggle,\n    getCellActions: props.getCellActions,\n    onDeleteSubRow: props.onDeleteSubRow,\n    onAddSubRow: props.onAddSubRow,\n    onDragEnter: handleDragEnter\n  };\n\n  if (cellRangeSelection) {\n    cellMetaData.onCellMouseDown = handleCellMouseDown;\n    cellMetaData.onCellMouseEnter = handleCellMouseEnter;\n  }\n\n  var interactionMasksMetaData = {\n    onCheckCellIsEditable: props.onCheckCellIsEditable,\n    onCellCopyPaste: props.onCellCopyPaste,\n    onGridRowsUpdated: handleGridRowsUpdated,\n    onDragHandleDoubleClick: handleDragHandleDoubleClick,\n    onCellSelected: props.onCellSelected,\n    onCellDeSelected: props.onCellDeSelected,\n    onCellRangeSelectionStarted: cellRangeSelection && cellRangeSelection.onStart,\n    onCellRangeSelectionUpdated: cellRangeSelection && cellRangeSelection.onUpdate,\n    onCellRangeSelectionCompleted: cellRangeSelection && cellRangeSelection.onComplete,\n    onCommit: handleCommit\n  };\n  var headerRows = getHeaderRows();\n  var rowOffsetHeight = headerRows[0].height + (headerRows[1] ? headerRows[1].height : 0);\n  return React.createElement(\"div\", {\n    className: \"rdg-root\",\n    style: {\n      width: width,\n      lineHeight: rowHeight + \"px\"\n    },\n    ref: gridRef\n  }, columnMetrics && React.createElement(React.Fragment, null, React.createElement(Header, {\n    ref: headerRef,\n    rowKey: rowKey,\n    rowsCount: rowsCount,\n    rowGetter: rowGetter,\n    columnMetrics: columnMetrics,\n    onColumnResize: handleColumnResize,\n    headerRows: headerRows,\n    sortColumn: props.sortColumn,\n    sortDirection: props.sortDirection,\n    draggableHeaderCell: props.draggableHeaderCell,\n    onSort: props.onGridSort,\n    onHeaderDrop: props.onHeaderDrop,\n    allRowsSelected: selectedRows !== undefined && selectedRows.size === rowsCount,\n    onSelectedRowsChange: onSelectedRowsChange,\n    getValidFilterValues: props.getValidFilterValues,\n    cellMetaData: cellMetaData\n  }), rowsCount === 0 && isValidElementType(props.emptyRowsView) ? createElement(props.emptyRowsView) : React.createElement(Canvas, {\n    rowKey: rowKey,\n    rowHeight: rowHeight,\n    rowRenderer: props.rowRenderer,\n    rowGetter: rowGetter,\n    rowsCount: rowsCount,\n    selectedRows: selectedRows,\n    onRowSelectionChange: handleRowSelectionChange,\n    columnMetrics: columnMetrics,\n    onScroll: handleScroll,\n    cellMetaData: cellMetaData,\n    height: minHeight - rowOffsetHeight,\n    scrollToRowIndex: props.scrollToRowIndex,\n    contextMenu: props.contextMenu,\n    getSubRowDetails: props.getSubRowDetails,\n    rowGroupRenderer: props.rowGroupRenderer,\n    enableCellSelect: enableCellSelect,\n    enableCellAutoFocus: enableCellAutoFocus,\n    cellNavigationMode: cellNavigationMode,\n    eventBus: eventBus,\n    interactionMasksMetaData: interactionMasksMetaData,\n    RowsContainer: props.RowsContainer,\n    editorPortalTarget: editorPortalTarget,\n    onCanvasKeydown: props.onGridKeyDown,\n    onCanvasKeyup: props.onGridKeyUp,\n    renderBatchSize: renderBatchSize,\n    summaryRows: props.summaryRows\n  })));\n}\n\nexport default forwardRef(DataGrid);","map":{"version":3,"sources":["../src/DataGrid.tsx"],"names":[],"mappings":"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","sourcesContent":["import React, {\n  forwardRef,\n  useState,\n  useRef,\n  useEffect,\n  useLayoutEffect,\n  useMemo,\n  useImperativeHandle,\n  createElement\n} from 'react';\nimport { isValidElementType } from 'react-is';\n\nimport Header, { HeaderHandle } from './Header';\nimport Canvas from './Canvas';\nimport { legacyCellContentRenderer } from './Cell/cellContentRenderers';\nimport { getColumnMetrics } from './utils/columnUtils';\nimport EventBus from './EventBus';\nimport { CellNavigationMode, EventTypes, UpdateActions, HeaderRowType, DEFINE_SORT } from './common/enums';\nimport {\n  AddFilterEvent,\n  CalculatedColumn,\n  CellActionButton,\n  CellCopyPasteEvent,\n  CellMetaData,\n  CheckCellIsEditableEvent,\n  Column,\n  CellContentRenderer,\n  CommitEvent,\n  GridRowsUpdatedEvent,\n  HeaderRowData,\n  InteractionMasksMetaData,\n  Position,\n  RowsContainerProps,\n  RowExpandToggleEvent,\n  RowGetter,\n  SelectedRange,\n  SubRowDetails,\n  SubRowOptions,\n  IRowRendererProps,\n  ScrollPosition\n} from './common/types';\n\nexport interface DataGridProps<R, K extends keyof R> {\n  /** An array of objects representing each column on the grid */\n  columns: Column<R>[];\n  /** The minimum width of the grid in pixels */\n  minWidth?: number;\n  /** The height of the header row in pixels */\n  headerRowHeight?: number;\n  /** The height of the header filter row in pixels */\n  headerFiltersHeight?: number;\n  /** Toggles whether filters row is displayed or not */\n  enableHeaderFilters?: boolean;\n  cellRangeSelection?: {\n    onStart(selectedRange: SelectedRange): void;\n    onUpdate?(selectedRange: SelectedRange): void;\n    onComplete?(selectedRange: SelectedRange): void;\n  };\n  /** Minimum column width in pixels */\n  minColumnWidth?: number;\n  /** Function called whenever row is clicked */\n  onRowClick?(rowIdx: number, rowData: R, column: CalculatedColumn<R>): void;\n  /** Function called whenever row is double clicked */\n  onRowDoubleClick?(rowIdx: number, rowData: R, column: CalculatedColumn<R>): void;\n  onAddFilter?(event: AddFilterEvent<R>): void;\n  /** Function called whenever grid is sorted*/\n  onGridSort?(columnKey: keyof R, direction: DEFINE_SORT): void;\n  /** Function called whenever keyboard key is released */\n  onGridKeyUp?(event: React.KeyboardEvent<HTMLDivElement>): void;\n  /** Function called whenever keyboard key is pressed down */\n  onGridKeyDown?(event: React.KeyboardEvent<HTMLDivElement>): void;\n\n  selectedRows?: Set<R[K]>;\n  /** Function called whenever row selection is changed */\n  onSelectedRowsChange?(selectedRows: Set<R[K]>): void;\n\n  /**\n   * Callback called whenever row data is updated\n   * When editing is enabled, this callback will be called for the following scenarios\n   * 1. Using the supplied editor of the column. The default editor is the SimpleTextEditor.\n   * 2. Copy/pasting the value from one cell to another <kbd>CTRL</kbd>+<kbd>C</kbd>, <kbd>CTRL</kbd>+<kbd>V</kbd>\n   * 3. Update multiple cells by dragging the fill handle of a cell up or down to a destination cell.\n   * 4. Update all cells under a given cell by double clicking the cell's fill handle.\n   */\n  onGridRowsUpdated?<E extends GridRowsUpdatedEvent<R>>(event: E): void;\n  /** Called when a column is resized */\n  onColumnResize?(idx: number, width: number): void;\n\n  /** Grid Props */\n  /** The primary key property of each row */\n  rowKey?: K;\n  /** The height of each row in pixels */\n  rowHeight?: number;\n  defaultCellContentRenderer?: CellContentRenderer<R>;\n  rowRenderer?: React.ReactElement | React.ComponentType<IRowRendererProps<R>>;\n  rowGroupRenderer?: React.ComponentType;\n  /** A function called for each rendered row that should return a plain key/value pair object */\n  rowGetter: RowGetter<R>;\n  /** The number of rows to be rendered */\n  rowsCount: number;\n  /** The minimum height of the grid in pixels */\n  minHeight?: number;\n  /** When set, grid will scroll to this row index */\n  scrollToRowIndex?: number;\n  /** Component used to render a context menu. react-data-grid-addons provides a default context menu which may be used*/\n  contextMenu?: React.ReactElement;\n  /** Used to toggle whether cells can be selected or not */\n  enableCellSelect?: boolean;\n  /** Toggles whether cells should be autofocused */\n  enableCellAutoFocus?: boolean;\n  cellNavigationMode?: CellNavigationMode;\n  /** The node where the editor portal should mount. */\n  editorPortalTarget?: Element;\n  /** The key of the column which is currently being sorted */\n  sortColumn?: keyof R;\n  /** The direction to sort the sortColumn*/\n  sortDirection?: DEFINE_SORT;\n  /** Called when the grid is scrolled */\n  onScroll?(scrollPosition: ScrollPosition): void;\n  /** Component used to render a draggable header cell */\n  draggableHeaderCell?: React.ComponentType<{ column: CalculatedColumn<R>; onHeaderDrop(): void }>;\n  getValidFilterValues?(columnKey: keyof R): unknown;\n  RowsContainer?: React.ComponentType<RowsContainerProps>;\n  emptyRowsView?: React.ComponentType<{}>;\n  onHeaderDrop?(): void;\n  getSubRowDetails?(row: R): SubRowDetails;\n\n  /** CellMetaData */\n  getCellActions?(column: CalculatedColumn<R>, rowData: R): CellActionButton[] | undefined;\n  /** Called whenever a sub row is deleted from the grid */\n  onDeleteSubRow?(options: SubRowOptions<R>): void;\n  /** Called whenever a sub row is added to the grid */\n  onAddSubRow?(): void;\n  /** Function called whenever a cell has been expanded */\n  onCellExpand?(options: SubRowOptions<R>): void;\n  onRowExpandToggle?(event: RowExpandToggleEvent): void;\n\n  /** InteractionMasksMetaData */\n  /** Deprecated: Function called when grid is updated via a copy/paste. Use onGridRowsUpdated instead*/\n  onCellCopyPaste?(event: CellCopyPasteEvent<R>): void;\n  /** Function called whenever a cell is selected */\n  onCellSelected?(position: Position): void;\n  /** Function called whenever a cell is deselected */\n  onCellDeSelected?(position: Position): void;\n  /** called before cell is set active, returns a boolean to determine whether cell is editable */\n  onCheckCellIsEditable?(event: CheckCellIsEditableEvent<R>): boolean;\n  /**\n   * Rows to be pinned at the bottom of the rows view for summary, the vertical scroll bar will not scroll these rows.\n   * Bottom horizontal scroll bar can move the row left / right. Or a customized row renderer can be used to disabled the scrolling support.\n   */\n  summaryRows?: R[];\n  /** Control how big render row batches will be. */\n  renderBatchSize?: number;\n}\n\nexport interface DataGridHandle {\n  scrollToColumn(colIdx: number): void;\n  selectCell(position: Position, openEditor?: boolean): void;\n  openCellEditor(rowIdx: number, colIdx: number): void;\n}\n\n/**\n * Main API Component to render a data grid of rows and columns\n *\n * @example\n *\n * <DataGrid columns={columns} rowGetter={i => rows[i]} rowsCount={3} />\n*/\nfunction DataGrid<R, K extends keyof R>({\n  rowKey = 'id' as K,\n  rowHeight = 35,\n  headerFiltersHeight = 45,\n  minColumnWidth = 80,\n  minHeight = 350,\n  minWidth: width,\n  enableCellSelect = false,\n  enableCellAutoFocus = true,\n  cellNavigationMode = CellNavigationMode.NONE,\n  editorPortalTarget = document.body,\n  renderBatchSize = 8,\n  defaultCellContentRenderer = legacyCellContentRenderer,\n  columns,\n  rowsCount,\n  rowGetter,\n  cellRangeSelection,\n  selectedRows,\n  onSelectedRowsChange,\n  ...props\n}: DataGridProps<R, K>, ref: React.Ref<DataGridHandle>) {\n  const [columnWidths, setColumnWidths] = useState(() => new Map<keyof R, number>());\n  const [eventBus] = useState(() => new EventBus());\n  const [gridWidth, setGridWidth] = useState(0);\n  const gridRef = useRef<HTMLDivElement>(null);\n  const headerRef = useRef<HeaderHandle>(null);\n  const lastSelectedRowIdx = useRef(-1);\n  const viewportWidth = (width || gridWidth) - 2; // 2 for border width;\n  const scrollLeft = useRef(0);\n\n  const columnMetrics = useMemo(() => {\n    if (viewportWidth <= 0) return null;\n\n    return getColumnMetrics<R>({\n      columns,\n      minColumnWidth,\n      viewportWidth,\n      columnWidths,\n      defaultCellContentRenderer\n    });\n  }, [columnWidths, columns, defaultCellContentRenderer, minColumnWidth, viewportWidth]);\n\n  useLayoutEffect(() => {\n    // Do not calculate the width if minWidth is provided\n    if (width) return;\n    function onResize() {\n      // Immediately re-render when the component is mounted to get valid columnMetrics.\n      setGridWidth(gridRef.current!.getBoundingClientRect().width);\n    }\n    onResize();\n\n    window.addEventListener('resize', onResize);\n    return () => {\n      window.removeEventListener('resize', onResize);\n    };\n  }, [width]);\n\n  useEffect(() => {\n    if (!cellRangeSelection) return;\n\n    function handleWindowMouseUp() {\n      eventBus.dispatch(EventTypes.SELECT_END);\n    }\n\n    window.addEventListener('mouseup', handleWindowMouseUp);\n\n    return () => {\n      window.removeEventListener('mouseup', handleWindowMouseUp);\n    };\n  }, [eventBus, cellRangeSelection]);\n\n  function selectCell({ idx, rowIdx }: Position, openEditor?: boolean) {\n    eventBus.dispatch(EventTypes.SELECT_CELL, { rowIdx, idx }, openEditor);\n  }\n\n  function getColumn(idx: number) {\n    return columnMetrics!.columns[idx];\n  }\n\n  function handleColumnResize(column: CalculatedColumn<R>, width: number) {\n    const newColumnWidths = new Map(columnWidths);\n    width = Math.max(width, minColumnWidth);\n    newColumnWidths.set(column.key, width);\n    setColumnWidths(newColumnWidths);\n\n    if (props.onColumnResize) {\n      props.onColumnResize(column.idx, width);\n    }\n  }\n\n  function handleScroll(scrollPosition: ScrollPosition) {\n    if (headerRef.current && scrollLeft.current !== scrollPosition.scrollLeft) {\n      scrollLeft.current = scrollPosition.scrollLeft;\n      headerRef.current.setScrollLeft(scrollPosition.scrollLeft);\n    }\n    if (props.onScroll) {\n      props.onScroll(scrollPosition);\n    }\n  }\n\n  function handleDragEnter(overRowIdx: number) {\n    eventBus.dispatch(EventTypes.DRAG_ENTER, overRowIdx);\n  }\n\n  function handleCellClick({ rowIdx, idx }: Position) {\n    const { onRowClick } = props;\n    selectCell({ rowIdx, idx });\n\n    if (onRowClick) {\n      onRowClick(rowIdx, rowGetter(rowIdx), getColumn(idx));\n    }\n  }\n\n  function handleCellMouseDown(position: Position) {\n    eventBus.dispatch(EventTypes.SELECT_START, position);\n  }\n\n  function handleCellMouseEnter(position: Position) {\n    eventBus.dispatch(EventTypes.SELECT_UPDATE, position);\n  }\n\n  function handleCellContextMenu(position: Position) {\n    selectCell(position);\n  }\n\n  function handleCellDoubleClick({ rowIdx, idx }: Position) {\n    const { onRowDoubleClick } = props;\n    if (onRowDoubleClick) {\n      onRowDoubleClick(rowIdx, rowGetter(rowIdx), getColumn(idx));\n    }\n    openCellEditor(rowIdx, idx);\n  }\n\n  const handleDragHandleDoubleClick: InteractionMasksMetaData<R>['onDragHandleDoubleClick'] = (e) => {\n    const cellKey = getColumn(e.idx).key;\n    handleGridRowsUpdated(cellKey, e.rowIdx, rowsCount - 1, { [cellKey]: e.rowData[cellKey] }, UpdateActions.COLUMN_FILL);\n  };\n\n  const handleGridRowsUpdated: InteractionMasksMetaData<R>['onGridRowsUpdated'] = (cellKey, fromRow, toRow, updated, action, originRow) => {\n    const { onGridRowsUpdated } = props;\n    if (!onGridRowsUpdated) {\n      return;\n    }\n\n    const rowIds = [];\n    const start = Math.min(fromRow, toRow);\n    const end = Math.max(fromRow, toRow);\n\n    for (let i = start; i <= end; i++) {\n      rowIds.push(rowGetter(i)[rowKey]);\n    }\n\n    const fromRowData = rowGetter(action === UpdateActions.COPY_PASTE ? originRow! : fromRow);\n    const fromRowId = fromRowData[rowKey];\n    const toRowId = rowGetter(toRow)[rowKey];\n    onGridRowsUpdated({ cellKey, fromRow, toRow, fromRowId, toRowId, rowIds, updated: updated as never, action, fromRowData });\n  };\n\n  function handleCommit(commit: CommitEvent<R>) {\n    const targetRow = commit.rowIdx;\n    handleGridRowsUpdated(commit.cellKey, targetRow, targetRow, commit.updated, UpdateActions.CELL_UPDATE);\n  }\n\n  function getHeaderRows(): [HeaderRowData<R>, HeaderRowData<R> | undefined] {\n    const { headerRowHeight, onAddFilter } = props;\n    return [\n      { height: headerRowHeight || rowHeight, rowType: HeaderRowType.HEADER },\n      props.enableHeaderFilters ? {\n        rowType: HeaderRowType.FILTER,\n        filterable: true,\n        onFilterChange: onAddFilter,\n        height: headerFiltersHeight || headerRowHeight || rowHeight\n      } : undefined\n    ];\n  }\n\n  function openCellEditor(rowIdx: number, idx: number) {\n    selectCell({ rowIdx, idx }, true);\n  }\n\n  function scrollToColumn(colIdx: number) {\n    eventBus.dispatch(EventTypes.SCROLL_TO_COLUMN, colIdx);\n  }\n\n  function handleRowSelectionChange(rowIdx: number, row: R, checked: boolean, isShiftClick: boolean) {\n    if (!onSelectedRowsChange) return;\n\n    const newSelectedRows = new Set(selectedRows);\n\n    if (checked) {\n      newSelectedRows.add(row[rowKey]);\n      const previousRowIdx = lastSelectedRowIdx.current;\n      lastSelectedRowIdx.current = rowIdx;\n      if (isShiftClick && previousRowIdx !== -1 && previousRowIdx !== rowIdx) {\n        const step = Math.sign(rowIdx - previousRowIdx);\n        for (let i = previousRowIdx + step; i !== rowIdx; i += step) {\n          newSelectedRows.add(rowGetter(i)[rowKey]);\n        }\n      }\n    } else {\n      newSelectedRows.delete(row[rowKey]);\n      lastSelectedRowIdx.current = -1;\n    }\n\n    onSelectedRowsChange(newSelectedRows);\n  }\n\n  useImperativeHandle(ref, () => ({\n    scrollToColumn,\n    selectCell,\n    openCellEditor\n  }));\n\n  const cellMetaData: CellMetaData<R> = {\n    rowKey,\n    onCellClick: handleCellClick,\n    onCellContextMenu: handleCellContextMenu,\n    onCellDoubleClick: handleCellDoubleClick,\n    onCellExpand: props.onCellExpand,\n    onRowExpandToggle: props.onRowExpandToggle,\n    getCellActions: props.getCellActions,\n    onDeleteSubRow: props.onDeleteSubRow,\n    onAddSubRow: props.onAddSubRow,\n    onDragEnter: handleDragEnter\n  };\n  if (cellRangeSelection) {\n    cellMetaData.onCellMouseDown = handleCellMouseDown;\n    cellMetaData.onCellMouseEnter = handleCellMouseEnter;\n  }\n\n  const interactionMasksMetaData: InteractionMasksMetaData<R> = {\n    onCheckCellIsEditable: props.onCheckCellIsEditable,\n    onCellCopyPaste: props.onCellCopyPaste,\n    onGridRowsUpdated: handleGridRowsUpdated,\n    onDragHandleDoubleClick: handleDragHandleDoubleClick,\n    onCellSelected: props.onCellSelected,\n    onCellDeSelected: props.onCellDeSelected,\n    onCellRangeSelectionStarted: cellRangeSelection && cellRangeSelection.onStart,\n    onCellRangeSelectionUpdated: cellRangeSelection && cellRangeSelection.onUpdate,\n    onCellRangeSelectionCompleted: cellRangeSelection && cellRangeSelection.onComplete,\n    onCommit: handleCommit\n  };\n\n  const headerRows = getHeaderRows();\n  const rowOffsetHeight = headerRows[0].height + (headerRows[1] ? headerRows[1].height : 0);\n\n  return (\n    <div\n      className=\"rdg-root\"\n      style={{ width, lineHeight: `${rowHeight}px` }}\n      ref={gridRef}\n    >\n      {columnMetrics && (\n        <>\n          <Header<R, K>\n            ref={headerRef}\n            rowKey={rowKey}\n            rowsCount={rowsCount}\n            rowGetter={rowGetter}\n            columnMetrics={columnMetrics}\n            onColumnResize={handleColumnResize}\n            headerRows={headerRows}\n            sortColumn={props.sortColumn}\n            sortDirection={props.sortDirection}\n            draggableHeaderCell={props.draggableHeaderCell}\n            onSort={props.onGridSort}\n            onHeaderDrop={props.onHeaderDrop}\n            allRowsSelected={selectedRows !== undefined && selectedRows.size === rowsCount}\n            onSelectedRowsChange={onSelectedRowsChange}\n            getValidFilterValues={props.getValidFilterValues}\n            cellMetaData={cellMetaData}\n          />\n          {rowsCount === 0 && isValidElementType(props.emptyRowsView) ? createElement(props.emptyRowsView) : (\n            <Canvas<R, K>\n              rowKey={rowKey}\n              rowHeight={rowHeight}\n              rowRenderer={props.rowRenderer}\n              rowGetter={rowGetter}\n              rowsCount={rowsCount}\n              selectedRows={selectedRows}\n              onRowSelectionChange={handleRowSelectionChange}\n              columnMetrics={columnMetrics}\n              onScroll={handleScroll}\n              cellMetaData={cellMetaData}\n              height={minHeight - rowOffsetHeight}\n              scrollToRowIndex={props.scrollToRowIndex}\n              contextMenu={props.contextMenu}\n              getSubRowDetails={props.getSubRowDetails}\n              rowGroupRenderer={props.rowGroupRenderer}\n              enableCellSelect={enableCellSelect}\n              enableCellAutoFocus={enableCellAutoFocus}\n              cellNavigationMode={cellNavigationMode}\n              eventBus={eventBus}\n              interactionMasksMetaData={interactionMasksMetaData}\n              RowsContainer={props.RowsContainer}\n              editorPortalTarget={editorPortalTarget}\n              onCanvasKeydown={props.onGridKeyDown}\n              onCanvasKeyup={props.onGridKeyUp}\n              renderBatchSize={renderBatchSize}\n              summaryRows={props.summaryRows}\n            />\n          )}\n        </>\n      )}\n    </div>\n  );\n}\n\nexport default forwardRef(\n  DataGrid as React.RefForwardingComponent<DataGridHandle, DataGridProps<{ [key: string]: unknown }, string>>\n) as <R, K extends keyof R>(props: DataGridProps<R, K> & { ref?: React.Ref<DataGridHandle> }) => JSX.Element;\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}