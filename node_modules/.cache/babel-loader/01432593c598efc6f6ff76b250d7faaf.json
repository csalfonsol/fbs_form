{"ast":null,"code":"import { __assign, __values } from \"tslib\";\nimport { getScrollbarSize } from './domUtils';\nexport function getColumnMetrics(metrics) {\n  var e_1, _a;\n\n  var left = 0;\n  var totalWidth = 0;\n  var allocatedWidths = 0;\n  var unassignedColumnsCount = 0;\n  var lastFrozenColumnIndex = -1;\n  var columns = [];\n\n  try {\n    for (var _b = __values(metrics.columns), _c = _b.next(); !_c.done; _c = _b.next()) {\n      var metricsColumn = _c.value;\n      var width = getSpecifiedWidth(metricsColumn, metrics.columnWidths, metrics.viewportWidth, metrics.minColumnWidth);\n\n      var column = __assign(__assign({}, metricsColumn), {\n        width: width\n      });\n\n      if (width === undefined) {\n        unassignedColumnsCount++;\n      } else {\n        allocatedWidths += width;\n      }\n\n      if (isFrozen(column)) {\n        lastFrozenColumnIndex++;\n        columns.splice(lastFrozenColumnIndex, 0, column);\n      } else {\n        columns.push(column);\n      }\n    }\n  } catch (e_1_1) {\n    e_1 = {\n      error: e_1_1\n    };\n  } finally {\n    try {\n      if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n    } finally {\n      if (e_1) throw e_1.error;\n    }\n  }\n\n  var unallocatedWidth = metrics.viewportWidth - allocatedWidths - getScrollbarSize();\n  var unallocatedColumnWidth = Math.max(Math.floor(unallocatedWidth / unassignedColumnsCount), metrics.minColumnWidth);\n  var calculatedColumns = columns.map(function (column, idx) {\n    // Every column should have a valid width as this stage\n    var width = column.width === undefined ? unallocatedColumnWidth : column.width;\n\n    var newColumn = __assign(__assign({}, column), {\n      idx: idx,\n      width: width,\n      left: left,\n      cellContentRenderer: column.cellContentRenderer || metrics.defaultCellContentRenderer\n    });\n\n    totalWidth += width;\n    left += width;\n    return newColumn;\n  });\n  return {\n    columns: calculatedColumns,\n    lastFrozenColumnIndex: lastFrozenColumnIndex,\n    totalColumnWidth: totalWidth,\n    viewportWidth: metrics.viewportWidth\n  };\n}\n\nfunction getSpecifiedWidth(column, columnWidths, viewportWidth, minColumnWidth) {\n  if (columnWidths.has(column.key)) {\n    // Use the resized width if available\n    return columnWidths.get(column.key);\n  }\n\n  if (typeof column.width === 'number') {\n    // TODO: allow width to be less than minWidth?\n    return Math.max(column.width, minColumnWidth);\n  }\n\n  if (typeof column.width === 'string' && /^\\d+%$/.test(column.width)) {\n    return Math.max(Math.floor(viewportWidth * parseInt(column.width, 10) / 100), minColumnWidth);\n  }\n} // Logic extented to allow for functions to be passed down in column.editable\n// this allows us to deicde whether we can be editing from a cell level\n\n\nexport function canEdit(column, rowData, enableCellSelect) {\n  if (typeof column.editable === 'function') {\n    return enableCellSelect === true && column.editable(rowData);\n  }\n\n  return enableCellSelect === true && (!!column.editor || !!column.editable);\n}\nexport function isFrozen(column) {\n  return column.frozen === true;\n}\nexport function getColumnScrollPosition(columns, idx, currentScrollLeft, currentClientWidth) {\n  var left = 0;\n  var frozen = 0;\n\n  for (var i = 0; i < idx; i++) {\n    var column = columns[i];\n\n    if (column) {\n      if (column.width) {\n        left += column.width;\n      }\n\n      if (isFrozen(column)) {\n        frozen += column.width;\n      }\n    }\n  }\n\n  var selectedColumn = columns[idx];\n\n  if (selectedColumn) {\n    var scrollLeft = left - frozen - currentScrollLeft;\n    var scrollRight = left + selectedColumn.width - currentScrollLeft;\n\n    if (scrollLeft < 0) {\n      return scrollLeft;\n    }\n\n    if (scrollRight > currentClientWidth) {\n      return scrollRight - currentClientWidth;\n    }\n  }\n\n  return 0;\n}","map":{"version":3,"sources":["../../src/utils/columnUtils.ts"],"names":[],"mappings":"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","sourcesContent":["import { Column, CalculatedColumn, ColumnMetrics, CellContentRenderer } from '../common/types';\nimport { getScrollbarSize } from './domUtils';\n\ninterface Metrics<R> {\n  columns: Column<R>[];\n  columnWidths: Map<keyof R, number>;\n  minColumnWidth: number;\n  viewportWidth: number;\n  defaultCellContentRenderer: CellContentRenderer<R>;\n}\n\nexport function getColumnMetrics<R>(metrics: Metrics<R>): ColumnMetrics<R> {\n  let left = 0;\n  let totalWidth = 0;\n  let allocatedWidths = 0;\n  let unassignedColumnsCount = 0;\n  let lastFrozenColumnIndex = -1;\n  const columns: Array<Column<R> & { width: number | void }> = [];\n\n  for (const metricsColumn of metrics.columns) {\n    const width = getSpecifiedWidth(metricsColumn, metrics.columnWidths, metrics.viewportWidth, metrics.minColumnWidth);\n    const column = { ...metricsColumn, width };\n\n    if (width === undefined) {\n      unassignedColumnsCount++;\n    } else {\n      allocatedWidths += width;\n    }\n\n    if (isFrozen(column)) {\n      lastFrozenColumnIndex++;\n      columns.splice(lastFrozenColumnIndex, 0, column);\n    } else {\n      columns.push(column);\n    }\n  }\n\n  const unallocatedWidth = metrics.viewportWidth - allocatedWidths - getScrollbarSize();\n  const unallocatedColumnWidth = Math.max(\n    Math.floor(unallocatedWidth / unassignedColumnsCount),\n    metrics.minColumnWidth\n  );\n\n  const calculatedColumns: CalculatedColumn<R>[] = columns.map((column, idx) => {\n    // Every column should have a valid width as this stage\n    const width = column.width === undefined ? unallocatedColumnWidth : column.width;\n    const newColumn: CalculatedColumn<R> = {\n      ...column,\n      idx,\n      width,\n      left,\n      cellContentRenderer: column.cellContentRenderer || metrics.defaultCellContentRenderer\n    };\n    totalWidth += width;\n    left += width;\n    return newColumn;\n  });\n\n  return {\n    columns: calculatedColumns,\n    lastFrozenColumnIndex,\n    totalColumnWidth: totalWidth,\n    viewportWidth: metrics.viewportWidth\n  };\n}\n\nfunction getSpecifiedWidth<R>(\n  column: Column<R>,\n  columnWidths: Map<keyof R, number>,\n  viewportWidth: number,\n  minColumnWidth: number\n): number | void {\n  if (columnWidths.has(column.key)) {\n    // Use the resized width if available\n    return columnWidths.get(column.key);\n  }\n  if (typeof column.width === 'number') {\n    // TODO: allow width to be less than minWidth?\n    return Math.max(column.width, minColumnWidth);\n  }\n  if (typeof column.width === 'string' && /^\\d+%$/.test(column.width)) {\n    return Math.max(Math.floor(viewportWidth * parseInt(column.width, 10) / 100), minColumnWidth);\n  }\n}\n\n// Logic extented to allow for functions to be passed down in column.editable\n// this allows us to deicde whether we can be editing from a cell level\nexport function canEdit<R>(column: CalculatedColumn<R>, rowData: R, enableCellSelect?: boolean): boolean {\n  if (typeof column.editable === 'function') {\n    return enableCellSelect === true && column.editable(rowData);\n  }\n  return enableCellSelect === true && (!!column.editor || !!column.editable);\n}\n\nexport function isFrozen<R>(column: Column<R> | CalculatedColumn<R>): boolean {\n  return column.frozen === true;\n}\n\nexport function getColumnScrollPosition<R>(columns: CalculatedColumn<R>[], idx: number, currentScrollLeft: number, currentClientWidth: number): number {\n  let left = 0;\n  let frozen = 0;\n\n  for (let i = 0; i < idx; i++) {\n    const column = columns[i];\n    if (column) {\n      if (column.width) {\n        left += column.width;\n      }\n      if (isFrozen(column)) {\n        frozen += column.width;\n      }\n    }\n  }\n\n  const selectedColumn = columns[idx];\n  if (selectedColumn) {\n    const scrollLeft = left - frozen - currentScrollLeft;\n    const scrollRight = left + selectedColumn.width - currentScrollLeft;\n\n    if (scrollLeft < 0) {\n      return scrollLeft;\n    }\n    if (scrollRight > currentClientWidth) {\n      return scrollRight - currentClientWidth;\n    }\n  }\n\n  return 0;\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}