{"ast":null,"code":"import { __assign, __read } from \"tslib\";\nimport React, { useCallback, useEffect, useMemo, useRef, useState } from 'react';\nimport { EventTypes } from './common/enums';\nimport InteractionMasks from './masks/InteractionMasks';\nimport RowRenderer from './RowRenderer';\nimport SummaryRowRenderer from './SummaryRowRenderer';\nimport { getColumnScrollPosition, getScrollbarSize, isPositionStickySupported } from './utils';\nimport { getHorizontalRangeToRender, getVerticalRangeToRender } from './utils/viewportUtils';\nexport default function Canvas(_a) {\n  var cellMetaData = _a.cellMetaData,\n      cellNavigationMode = _a.cellNavigationMode,\n      columnMetrics = _a.columnMetrics,\n      contextMenu = _a.contextMenu,\n      editorPortalTarget = _a.editorPortalTarget,\n      enableCellAutoFocus = _a.enableCellAutoFocus,\n      enableCellSelect = _a.enableCellSelect,\n      eventBus = _a.eventBus,\n      getSubRowDetails = _a.getSubRowDetails,\n      height = _a.height,\n      interactionMasksMetaData = _a.interactionMasksMetaData,\n      onCanvasKeydown = _a.onCanvasKeydown,\n      onCanvasKeyup = _a.onCanvasKeyup,\n      onRowSelectionChange = _a.onRowSelectionChange,\n      onScroll = _a.onScroll,\n      renderBatchSize = _a.renderBatchSize,\n      rowGetter = _a.rowGetter,\n      rowGroupRenderer = _a.rowGroupRenderer,\n      rowHeight = _a.rowHeight,\n      rowKey = _a.rowKey,\n      rowRenderer = _a.rowRenderer,\n      RowsContainer = _a.RowsContainer,\n      rowsCount = _a.rowsCount,\n      scrollToRowIndex = _a.scrollToRowIndex,\n      selectedRows = _a.selectedRows,\n      summaryRows = _a.summaryRows;\n\n  var _b = __read(useState(0), 2),\n      scrollTop = _b[0],\n      setScrollTop = _b[1];\n\n  var _c = __read(useState(0), 2),\n      scrollLeft = _c[0],\n      setScrollLeft = _c[1];\n\n  var canvas = useRef(null);\n  var summaryRef = useRef(null);\n  var prevScrollToRowIndex = useRef();\n\n  var _d = __read(useState(function () {\n    return new Map();\n  }), 1),\n      rowRefs = _d[0];\n\n  var clientHeight = getClientHeight();\n  var nonStickyScrollLeft = isPositionStickySupported() ? undefined : scrollLeft;\n\n  var _e = __read(getVerticalRangeToRender(clientHeight, rowHeight, scrollTop, rowsCount, renderBatchSize), 2),\n      rowOverscanStartIdx = _e[0],\n      rowOverscanEndIdx = _e[1];\n\n  var _f = useMemo(function () {\n    return getHorizontalRangeToRender({\n      columnMetrics: columnMetrics,\n      scrollLeft: scrollLeft\n    });\n  }, [columnMetrics, scrollLeft]),\n      colOverscanStartIdx = _f.colOverscanStartIdx,\n      colOverscanEndIdx = _f.colOverscanEndIdx,\n      colVisibleStartIdx = _f.colVisibleStartIdx,\n      colVisibleEndIdx = _f.colVisibleEndIdx;\n\n  useEffect(function () {\n    return eventBus.subscribe(EventTypes.SCROLL_TO_COLUMN, function (idx) {\n      return scrollToColumn(idx, columnMetrics.columns);\n    });\n  }, [columnMetrics.columns, eventBus]);\n  useEffect(function () {\n    if (prevScrollToRowIndex.current === scrollToRowIndex) return;\n    prevScrollToRowIndex.current = scrollToRowIndex;\n    var current = canvas.current;\n\n    if (typeof scrollToRowIndex === 'number' && current) {\n      current.scrollTop = scrollToRowIndex * rowHeight;\n    }\n  }, [rowHeight, scrollToRowIndex]);\n\n  function handleScroll(e) {\n    var _a = e.currentTarget,\n        scrollLeft = _a.scrollLeft,\n        scrollTop = _a.scrollTop;\n    setScrollLeft(scrollLeft);\n    setScrollTop(scrollTop);\n    onScroll({\n      scrollLeft: scrollLeft,\n      scrollTop: scrollTop\n    });\n\n    if (summaryRef.current) {\n      summaryRef.current.scrollLeft = scrollLeft;\n    }\n  }\n\n  function getClientHeight() {\n    if (canvas.current) return canvas.current.clientHeight;\n    var scrollbarSize = columnMetrics.totalColumnWidth > columnMetrics.viewportWidth ? getScrollbarSize() : 0;\n    return height - scrollbarSize;\n  }\n\n  function onHitBottomCanvas(_a) {\n    var rowIdx = _a.rowIdx;\n    var current = canvas.current;\n\n    if (current) {\n      // We do not need to check for the index being in range, as the scrollTop setter will adequately clamp the value.\n      current.scrollTop = (rowIdx + 1) * rowHeight - clientHeight;\n    }\n  }\n\n  function onHitTopCanvas(_a) {\n    var rowIdx = _a.rowIdx;\n    var current = canvas.current;\n\n    if (current) {\n      current.scrollTop = rowIdx * rowHeight;\n    }\n  }\n\n  function handleHitColummBoundary(_a) {\n    var idx = _a.idx;\n    scrollToColumn(idx, columnMetrics.columns);\n  }\n\n  function getRowColumns(rowIdx) {\n    var row = rowRefs.get(rowIdx);\n    return row && row.props ? row.props.columns : columnMetrics.columns;\n  }\n\n  function scrollToColumn(idx, columns) {\n    var current = canvas.current;\n    if (!current) return;\n    var scrollLeft = current.scrollLeft,\n        clientWidth = current.clientWidth;\n    var newScrollLeft = getColumnScrollPosition(columns, idx, scrollLeft, clientWidth);\n\n    if (newScrollLeft !== 0) {\n      current.scrollLeft = scrollLeft + newScrollLeft;\n    }\n  }\n\n  var setRowRef = useCallback(function (row, idx) {\n    if (row === null) {\n      rowRefs.delete(idx);\n    } else {\n      rowRefs.set(idx, row);\n    }\n  }, [rowRefs]);\n\n  function getViewportRows() {\n    var rowElements = [];\n\n    for (var idx = rowOverscanStartIdx; idx <= rowOverscanEndIdx; idx++) {\n      var rowData = rowGetter(idx);\n      rowElements.push(React.createElement(RowRenderer, {\n        key: idx,\n        idx: idx,\n        rowData: rowData,\n        setRowRef: setRowRef,\n        cellMetaData: cellMetaData,\n        colOverscanEndIdx: colOverscanEndIdx,\n        colOverscanStartIdx: colOverscanStartIdx,\n        columnMetrics: columnMetrics,\n        eventBus: eventBus,\n        getSubRowDetails: getSubRowDetails,\n        onRowSelectionChange: onRowSelectionChange,\n        rowGroupRenderer: rowGroupRenderer,\n        rowHeight: rowHeight,\n        rowKey: rowKey,\n        rowRenderer: rowRenderer,\n        scrollLeft: nonStickyScrollLeft,\n        selectedRows: selectedRows\n      }));\n    }\n\n    return rowElements;\n  }\n\n  var grid = React.createElement(\"div\", {\n    className: \"rdg-grid\",\n    style: {\n      width: columnMetrics.totalColumnWidth,\n      paddingTop: rowOverscanStartIdx * rowHeight,\n      paddingBottom: (rowsCount - 1 - rowOverscanEndIdx) * rowHeight\n    }\n  }, getViewportRows());\n\n  if (RowsContainer !== undefined) {\n    grid = React.createElement(RowsContainer, {\n      id: contextMenu ? contextMenu.props.id : 'rowsContainer'\n    }, grid);\n  }\n\n  var summary = summaryRows && summaryRows.length > 0 && React.createElement(\"div\", {\n    ref: summaryRef,\n    className: \"rdg-summary\"\n  }, summaryRows.map(function (rowData, idx) {\n    return React.createElement(SummaryRowRenderer, {\n      key: idx,\n      idx: idx,\n      rowData: rowData,\n      cellMetaData: cellMetaData,\n      colOverscanEndIdx: colOverscanEndIdx,\n      colOverscanStartIdx: colOverscanStartIdx,\n      columnMetrics: columnMetrics,\n      rowHeight: rowHeight,\n      scrollLeft: nonStickyScrollLeft\n    });\n  }));\n  return React.createElement(React.Fragment, null, React.createElement(\"div\", {\n    className: \"rdg-viewport\",\n    style: {\n      height: height - 2 - (summaryRows ? summaryRows.length * rowHeight + 2 : 0)\n    },\n    ref: canvas,\n    onScroll: handleScroll,\n    onKeyDown: onCanvasKeydown,\n    onKeyUp: onCanvasKeyup\n  }, React.createElement(InteractionMasks, __assign({\n    rowGetter: rowGetter,\n    rowsCount: rowsCount,\n    rowHeight: rowHeight,\n    columns: columnMetrics.columns,\n    height: clientHeight,\n    colVisibleStartIdx: colVisibleStartIdx,\n    colVisibleEndIdx: colVisibleEndIdx,\n    enableCellSelect: enableCellSelect,\n    enableCellAutoFocus: enableCellAutoFocus,\n    cellNavigationMode: cellNavigationMode,\n    eventBus: eventBus,\n    contextMenu: contextMenu,\n    onHitBottomBoundary: onHitBottomCanvas,\n    onHitTopBoundary: onHitTopCanvas,\n    onHitLeftBoundary: handleHitColummBoundary,\n    onHitRightBoundary: handleHitColummBoundary,\n    scrollLeft: scrollLeft,\n    scrollTop: scrollTop,\n    getRowColumns: getRowColumns,\n    editorPortalTarget: editorPortalTarget\n  }, interactionMasksMetaData)), grid), summary);\n}","map":{"version":3,"sources":["../src/Canvas.tsx"],"names":[],"mappings":"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","sourcesContent":["import React, { useCallback, useEffect, useMemo, useRef, useState } from 'react';\n\nimport { EventTypes } from './common/enums';\nimport { CalculatedColumn, CellMetaData, ColumnMetrics, InteractionMasksMetaData, Position, ScrollPosition } from './common/types';\nimport EventBus from './EventBus';\nimport InteractionMasks from './masks/InteractionMasks';\nimport { DataGridProps } from './DataGrid';\nimport Row from './Row';\nimport RowRenderer from './RowRenderer';\nimport SummaryRowRenderer from './SummaryRowRenderer';\nimport { getColumnScrollPosition, getScrollbarSize, isPositionStickySupported } from './utils';\nimport { getHorizontalRangeToRender, getVerticalRangeToRender } from './utils/viewportUtils';\n\ntype SharedDataGridProps<R, K extends keyof R> = Pick<DataGridProps<R, K>,\n| 'rowGetter'\n| 'rowsCount'\n| 'rowRenderer'\n| 'rowGroupRenderer'\n| 'scrollToRowIndex'\n| 'contextMenu'\n| 'RowsContainer'\n| 'getSubRowDetails'\n| 'selectedRows'\n| 'summaryRows'\n> & Required<Pick<DataGridProps<R, K>,\n| 'rowKey'\n| 'enableCellSelect'\n| 'rowHeight'\n| 'cellNavigationMode'\n| 'enableCellAutoFocus'\n| 'editorPortalTarget'\n| 'renderBatchSize'\n>>;\n\nexport interface CanvasProps<R, K extends keyof R> extends SharedDataGridProps<R, K> {\n  columnMetrics: ColumnMetrics<R>;\n  cellMetaData: CellMetaData<R>;\n  height: number;\n  eventBus: EventBus;\n  interactionMasksMetaData: InteractionMasksMetaData<R>;\n  onScroll(position: ScrollPosition): void;\n  onCanvasKeydown?(e: React.KeyboardEvent<HTMLDivElement>): void;\n  onCanvasKeyup?(e: React.KeyboardEvent<HTMLDivElement>): void;\n  onRowSelectionChange(rowIdx: number, row: R, checked: boolean, isShiftClick: boolean): void;\n}\n\nexport default function Canvas<R, K extends keyof R>({\n  cellMetaData,\n  cellNavigationMode,\n  columnMetrics,\n  contextMenu,\n  editorPortalTarget,\n  enableCellAutoFocus,\n  enableCellSelect,\n  eventBus,\n  getSubRowDetails,\n  height,\n  interactionMasksMetaData,\n  onCanvasKeydown,\n  onCanvasKeyup,\n  onRowSelectionChange,\n  onScroll,\n  renderBatchSize,\n  rowGetter,\n  rowGroupRenderer,\n  rowHeight,\n  rowKey,\n  rowRenderer,\n  RowsContainer,\n  rowsCount,\n  scrollToRowIndex,\n  selectedRows,\n  summaryRows\n}: CanvasProps<R, K>) {\n  const [scrollTop, setScrollTop] = useState(0);\n  const [scrollLeft, setScrollLeft] = useState(0);\n  const canvas = useRef<HTMLDivElement>(null);\n  const summaryRef = useRef<HTMLDivElement>(null);\n  const prevScrollToRowIndex = useRef<number | undefined>();\n  const [rowRefs] = useState(() => new Map<number, Row<R>>());\n\n  const clientHeight = getClientHeight();\n  const nonStickyScrollLeft = isPositionStickySupported() ? undefined : scrollLeft;\n\n  const [rowOverscanStartIdx, rowOverscanEndIdx] = getVerticalRangeToRender(\n    clientHeight,\n    rowHeight,\n    scrollTop,\n    rowsCount,\n    renderBatchSize\n  );\n\n  const { colOverscanStartIdx, colOverscanEndIdx, colVisibleStartIdx, colVisibleEndIdx } = useMemo(() => {\n    return getHorizontalRangeToRender({\n      columnMetrics,\n      scrollLeft\n    });\n  }, [columnMetrics, scrollLeft]);\n\n  useEffect(() => {\n    return eventBus.subscribe(EventTypes.SCROLL_TO_COLUMN, idx => scrollToColumn(idx, columnMetrics.columns));\n  }, [columnMetrics.columns, eventBus]);\n\n  useEffect(() => {\n    if (prevScrollToRowIndex.current === scrollToRowIndex) return;\n    prevScrollToRowIndex.current = scrollToRowIndex;\n    const { current } = canvas;\n    if (typeof scrollToRowIndex === 'number' && current) {\n      current.scrollTop = scrollToRowIndex * rowHeight;\n    }\n  }, [rowHeight, scrollToRowIndex]);\n\n  function handleScroll(e: React.UIEvent<HTMLDivElement>) {\n    const { scrollLeft, scrollTop } = e.currentTarget;\n    setScrollLeft(scrollLeft);\n    setScrollTop(scrollTop);\n    onScroll({ scrollLeft, scrollTop });\n    if (summaryRef.current) {\n      summaryRef.current.scrollLeft = scrollLeft;\n    }\n  }\n\n  function getClientHeight() {\n    if (canvas.current) return canvas.current.clientHeight;\n    const scrollbarSize = columnMetrics.totalColumnWidth > columnMetrics.viewportWidth ? getScrollbarSize() : 0;\n    return height - scrollbarSize;\n  }\n\n  function onHitBottomCanvas({ rowIdx }: Position) {\n    const { current } = canvas;\n    if (current) {\n      // We do not need to check for the index being in range, as the scrollTop setter will adequately clamp the value.\n      current.scrollTop = (rowIdx + 1) * rowHeight - clientHeight;\n    }\n  }\n\n  function onHitTopCanvas({ rowIdx }: Position) {\n    const { current } = canvas;\n    if (current) {\n      current.scrollTop = rowIdx * rowHeight;\n    }\n  }\n\n  function handleHitColummBoundary({ idx }: Position) {\n    scrollToColumn(idx, columnMetrics.columns);\n  }\n\n  function getRowColumns(rowIdx: number) {\n    const row = rowRefs.get(rowIdx);\n    return row && row.props ? row.props.columns : columnMetrics.columns;\n  }\n\n  function scrollToColumn(idx: number, columns: CalculatedColumn<R>[]) {\n    const { current } = canvas;\n    if (!current) return;\n\n    const { scrollLeft, clientWidth } = current;\n    const newScrollLeft = getColumnScrollPosition(columns, idx, scrollLeft, clientWidth);\n    if (newScrollLeft !== 0) {\n      current.scrollLeft = scrollLeft + newScrollLeft;\n    }\n  }\n\n  const setRowRef = useCallback((row: Row<R> | null, idx: number) => {\n    if (row === null) {\n      rowRefs.delete(idx);\n    } else {\n      rowRefs.set(idx, row);\n    }\n  }, [rowRefs]);\n\n  function getViewportRows() {\n    const rowElements = [];\n    for (let idx = rowOverscanStartIdx; idx <= rowOverscanEndIdx; idx++) {\n      const rowData = rowGetter(idx);\n      rowElements.push(\n        <RowRenderer<R, K>\n          key={idx}\n          idx={idx}\n          rowData={rowData}\n          setRowRef={setRowRef}\n          cellMetaData={cellMetaData}\n          colOverscanEndIdx={colOverscanEndIdx}\n          colOverscanStartIdx={colOverscanStartIdx}\n          columnMetrics={columnMetrics}\n          eventBus={eventBus}\n          getSubRowDetails={getSubRowDetails}\n          onRowSelectionChange={onRowSelectionChange}\n          rowGroupRenderer={rowGroupRenderer}\n          rowHeight={rowHeight}\n          rowKey={rowKey}\n          rowRenderer={rowRenderer}\n          scrollLeft={nonStickyScrollLeft}\n          selectedRows={selectedRows}\n        />\n      );\n    }\n\n    return rowElements;\n  }\n\n  let grid = (\n    <div\n      className=\"rdg-grid\"\n      style={{\n        width: columnMetrics.totalColumnWidth,\n        paddingTop: rowOverscanStartIdx * rowHeight,\n        paddingBottom: (rowsCount - 1 - rowOverscanEndIdx) * rowHeight\n      }}\n    >\n      {getViewportRows()}\n    </div>\n  );\n\n  if (RowsContainer !== undefined) {\n    grid = <RowsContainer id={contextMenu ? contextMenu.props.id : 'rowsContainer'}>{grid}</RowsContainer>;\n  }\n\n  const summary = summaryRows && summaryRows.length > 0 && (\n    <div ref={summaryRef} className=\"rdg-summary\">\n      {summaryRows.map((rowData, idx) => (\n        <SummaryRowRenderer<R, K>\n          key={idx}\n          idx={idx}\n          rowData={rowData}\n          cellMetaData={cellMetaData}\n          colOverscanEndIdx={colOverscanEndIdx}\n          colOverscanStartIdx={colOverscanStartIdx}\n          columnMetrics={columnMetrics}\n          rowHeight={rowHeight}\n          scrollLeft={nonStickyScrollLeft}\n        />\n      ))}\n    </div>\n  );\n\n  return (\n    <>\n      <div\n        className=\"rdg-viewport\"\n        style={{ height: height - 2 - (summaryRows ? summaryRows.length * rowHeight + 2 : 0) }}\n        ref={canvas}\n        onScroll={handleScroll}\n        onKeyDown={onCanvasKeydown}\n        onKeyUp={onCanvasKeyup}\n      >\n        <InteractionMasks<R, K>\n          rowGetter={rowGetter}\n          rowsCount={rowsCount}\n          rowHeight={rowHeight}\n          columns={columnMetrics.columns}\n          height={clientHeight}\n          colVisibleStartIdx={colVisibleStartIdx}\n          colVisibleEndIdx={colVisibleEndIdx}\n          enableCellSelect={enableCellSelect}\n          enableCellAutoFocus={enableCellAutoFocus}\n          cellNavigationMode={cellNavigationMode}\n          eventBus={eventBus}\n          contextMenu={contextMenu}\n          onHitBottomBoundary={onHitBottomCanvas}\n          onHitTopBoundary={onHitTopCanvas}\n          onHitLeftBoundary={handleHitColummBoundary}\n          onHitRightBoundary={handleHitColummBoundary}\n          scrollLeft={scrollLeft}\n          scrollTop={scrollTop}\n          getRowColumns={getRowColumns}\n          editorPortalTarget={editorPortalTarget}\n          {...interactionMasksMetaData}\n        />\n        {grid}\n      </div>\n      {summary}\n    </>\n  );\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}